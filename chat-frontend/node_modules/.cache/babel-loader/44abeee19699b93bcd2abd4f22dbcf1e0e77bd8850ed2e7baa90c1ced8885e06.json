{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst useWebSocket = () => {\n  _s();\n  const [connected, setConnected] = useState(false);\n  const [messages, setMessages] = useState([]);\n  const wsRef = useRef(null);\n  const connect = useCallback(() => {\n    wsRef.current = new WebSocket('ws://localhost:3000/ws');\n    wsRef.current.onopen = () => {\n      setConnected(true);\n      console.log('Connected to chat server');\n    };\n    wsRef.current.onmessage = event => {\n      console.log('Message received:', event.data);\n      try {\n        const message = JSON.parse(event.data);\n        setMessages(prev => {\n          // Check if this message already exists\n          const isDuplicate = prev.some(m => m.timestamp === message.timestamp && m.content === message.content && m.sender === message.sender);\n          if (isDuplicate) {\n            return prev;\n          }\n          return [...prev, message];\n        });\n      } catch (error) {\n        console.error('Error parsing message:', error);\n      }\n    };\n    wsRef.current.onclose = () => {\n      console.log('WebSocket connection closed');\n      setConnected(false);\n      setTimeout(connect, 3000);\n    };\n    wsRef.current.onerror = error => {\n      console.error('WebSocket error:', error);\n      setConnected(false);\n    };\n  }, []);\n  useEffect(() => {\n    connect();\n    return () => {\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n    };\n  }, [connect]);\n  const sendMessage = useCallback(content => {\n    if (wsRef.current && connected) {\n      const message = {\n        content,\n        timestamp: new Date().toISOString() // Use ISO string for consistent comparison\n      };\n      console.log('Sending message:', message);\n      wsRef.current.send(JSON.stringify(message));\n      return true;\n    }\n    return false;\n  }, [connected]);\n  return {\n    connected,\n    messages,\n    sendMessage\n  };\n};\n_s(useWebSocket, \"Jz689s2u7DiH0Yorr4ZXfLbIU8w=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","_s","connected","setConnected","messages","setMessages","wsRef","connect","current","WebSocket","onopen","console","log","onmessage","event","data","message","JSON","parse","prev","isDuplicate","some","m","timestamp","content","sender","error","onclose","setTimeout","onerror","close","sendMessage","Date","toISOString","send","stringify"],"sources":["/home/jon/kubernetes/3/chat-frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\nconst useWebSocket = () => {\n    const [connected, setConnected] = useState(false);\n    const [messages, setMessages] = useState([]);\n    const wsRef = useRef(null);\n\n    const connect = useCallback(() => {\n        wsRef.current = new WebSocket('ws://localhost:3000/ws');\n\n        wsRef.current.onopen = () => {\n            setConnected(true);\n            console.log('Connected to chat server');\n        };\n\n        wsRef.current.onmessage = (event) => {\n            console.log('Message received:', event.data);\n            try {\n                const message = JSON.parse(event.data);\n                setMessages(prev => {\n                    // Check if this message already exists\n                    const isDuplicate = prev.some(\n                        m => m.timestamp === message.timestamp &&\n                            m.content === message.content &&\n                            m.sender === message.sender\n                    );\n                    if (isDuplicate) {\n                        return prev;\n                    }\n                    return [...prev, message];\n                });\n            } catch (error) {\n                console.error('Error parsing message:', error);\n            }\n        };\n\n        wsRef.current.onclose = () => {\n            console.log('WebSocket connection closed');\n            setConnected(false);\n            setTimeout(connect, 3000);\n        };\n\n        wsRef.current.onerror = (error) => {\n            console.error('WebSocket error:', error);\n            setConnected(false);\n        };\n    }, []);\n\n    useEffect(() => {\n        connect();\n        return () => {\n            if (wsRef.current) {\n                wsRef.current.close();\n            }\n        };\n    }, [connect]);\n\n    const sendMessage = useCallback((content) => {\n        if (wsRef.current && connected) {\n            const message = {\n                content,\n                timestamp: new Date().toISOString()  // Use ISO string for consistent comparison\n            };\n            console.log('Sending message:', message);\n            wsRef.current.send(JSON.stringify(message));\n            return true;\n        }\n        return false;\n    }, [connected]);\n\n    return { connected, messages, sendMessage };\n};\n\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}